# A. Three swimmers

### 题意

给定四个正整数$p,a,b,c(p,a,b,c \le 10^{18})$，从某时刻开始，每隔$a,b,c$秒就分别会有一个苹果从树上落下，旁边的你在计时开始过了$p$秒后站到了苹果树下，求还要过几秒你会被苹果砸。

### 思路

也没什么技巧，直接求$min(⌈\dfrac{p}{a}⌉⋅a,⌈\dfrac{p}{b}⌉⋅b,⌈\dfrac{p}{c}⌉⋅c)−p$就可以了。

******

# B. Card Deck

### 题意

共$t(t \le 1000)$组数据，每组数据给定$n(n \le 10^5  )$张编好号的牌，每张牌都有唯一的面值$p_i$，一开始这$n$张牌按编号从小到大依次从下到上摆放组成一个牌堆，现有一种操作，每次从牌堆上方取走$n$张牌，不改变顺序地将其移到另一个新牌堆中，直到原来的牌堆备取完，若定义新牌堆的价值为$\sum_{i=1}^{n}n^{n-i}p_{i}$，求当新牌堆面值最大时的新牌堆。

### 思路

看到题目中$\sum_{i=1}^{n}n^{n-i}p_{i}$这样一个没有实际意义而且还很复杂的表达式，我们便需要思考为什么出题人为什么会选择，准确地说是构造，这样一个式子，很明显其满足了某种隐含的条件并可以大大简化我们的解题过程，通过手玩样例我们可以发现似乎只要每次都从旧牌堆中选出剩余牌中最大的牌并放到新牌堆中便可以使得新牌堆的价值最大，那么问题便转为了如何在$n$个数中寻找最大的数所在的位置，有的人一看到就说可以用线段树，但注意到一开始的$n$个数无论是面值大小还是相互的位置都不会发生改变，而且线段树每次查找复杂度为$O(log2)$很容易T，所以我们选择st表这样一种不支持修改但可以$O(1)$求区间最值的数据结构，而这题只要在st表的模板上再加一个存放最值所在位置的编号的数组就可以了。

# C. Maximum width

### 题意

给两个长度分别为$(n,m,m \le n \le 2 \cdot 10^{5})$的字符串$s$和$t$，若序列$P$满足任意$s_{p_{i}}=t_{i}$则称序列$P$为和谐序列，求所有的和谐序列中$\max(p_{i+1}-p_{i})$

### 思路

看到$n,m$的范围我们发现不能简单地采用区间DP的方法求解，观察题目中的$\max(p_{i+1}-p_{i})$，假设$t_{i}$和$t_{i+1}$不变的话，要想使$p_{i+1}-p_{i}$最大则需选择$s$中某个子字符串的两端，而且这个子字符串$st$要满足$st$以$t_{i}$开头，$t_{i+1}$结尾，由此我们可以尝试构造$left$和$right$数组，其中$left_{i}$为$s$中在$left_{i-1}$右侧且最早出现$t_{i}$的字符的位置，类似的，$right_{i}$为在$right_{i+1}$左侧最早出现$t_{i}$的字符的位置。那么$max(p_{i+1}-p_{i})$即为$right_{i+1}-left_{i}$，至于如何求出$left$和$right$数组，我们可以用两次two pointer，第一次一个指针从0到m，另一个指针从0到n求出$left$数组，第二次一个指针从0到m，另一个指针从n到0求出$right$数组，然后我们遍历一遍就可以求出最后的答案。
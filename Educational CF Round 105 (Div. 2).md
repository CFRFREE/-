# A. ABC String

### 题意

共$t(1≤t≤1000)$组数据，每组数据为一个仅由“a”,”b”,”c”组成的字符串，题目保证字符串的长度是偶数，这个字符串的每一位都对应着“(”或“)”两种括号，字符串相同的字母代表的括号方向也一致，请问是否存在一种对应方式使得最后的括号序列是合法的。

### 思路

单纯地判断一个括号序列是否合法是很简单的，这一题的难点是由字母序列向括号序列的转换，但我们发现一共只有三种字母，所以时间复杂度允许我们去枚举每一种字母所对应的括号方向。这里存在一个优化就是如果要存在一种合法序列，那么$max(a,b,c)=\dfrac{n}{2}$，出现次数最多的字母代表一种括号，剩下两种代表另外一种。除此之外，我们发现一个合法的括号序列一定是以“(”开头，这也可以大大优化我们的时间复杂度。

*******

# B. Berland Crossword

### 题意

给定一个边长为$n$的正方形，这个正方形由$n*n$个白色小方块组成，现在要求把一部分白色小方块涂黑，并给出最后正方形上下左右被涂黑的方块的数量$U,D,L,R$，请问是否存在能满足此要求的填涂方案。

### 思路

我们发现如果一种方案不满足条件往往是因为正方形四个边角的小方块的颜色会同时影响到相邻的两条边，比如如果要同时满足上边涂$n$个，左边或右边涂$0$个,那么是不可能的，因为上边在涂满的时候势必会影响到左右两边，于是乎我在考场上写了一个比较复杂的判断，具体的原理比较冗长，这里就直接放上判断部分的代码了

```c++
int check()
{
	if (U + R + D + L == 0)
		return 1;
	if ((U == n || D == n) && L * R == 0)
		return 0;
	if ((R == n || L == n) && U * D == 0)
		return 0;
	if ((U == n && D == n) && (L < 2 || R < 2))
		return 0;
	if ((L == n && R == n) && (U < 2 || D < 2))
		return 0;
	if ((U == n - 1 || D == n - 1) && L + R == 0)
		return 0;
	if ((L == n - 1 || R == n - 1) && U + D == 0)
		return 0;
	if ((U == n - 1 && D == n - 1) && L + R <= 1)
		return 0;
	if ((L == n - 1 && R == n - 1) && U + D <= 1)
		return 0;
	if ((U+D==2*n-1) && (L <= 1 && R <= 1))
		return 0;
	if ((L+R==2*n-1) && (U <= 1 && D <= 1))
		return 0;
	return 1;
}
```

比赛完后看题解发现因为会影响结果的只有正方形四个角块，所以我们可以二进制枚举每一个角块的颜色所对应的16种可能，然后进行判断，代码如下：

```c++
void work()
{
	for(int i=0; i<=15; i++)
	{
		int u=U, r=R, d=D, l=L;
		if(i & 1)
		{
			u--;
			l--;
		}
		if(i & 2)
		{
			u--;
			r--;
		}
		if(i & 4)
		{
			r--;
			d--;
		}
		if(i & 8)
		{
			d--;
			l--;
		}
		if( u>=0&&r>=0&&d>=0&&l>=0 && u<=n-2&&r<=n-2&&l<=n-2&&d<=n-2 )
		{
			printf("YES\n");
			return;
		}
	}
	printf("NO\n");
}
```

